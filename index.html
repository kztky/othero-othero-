<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>パステルオセロ</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.json" />
  <link rel="icon" sizes="192x192" href="./icon-192.png" />
  <link rel="icon" sizes="512x512" href="./icon-512.png" />

  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gradient-to-br from-blue-50 to-green-50 min-h-screen">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    const BOARD_SIZE = 8;
    const EMPTY = 0;
    const BLACK = 1;
    const WHITE = 2;

    const DIFFICULTY = ["easy", "normal", "hard"];

    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [ 0, -1],          [ 0, 1],
      [ 1, -1], [ 1, 0], [ 1, 1],
    ];

    const getInitialBoard = () => {
      const b = Array.from({ length: BOARD_SIZE }, () =>
        Array(BOARD_SIZE).fill(EMPTY)
      );
      b[3][3] = WHITE;
      b[3][4] = BLACK;
      b[4][3] = BLACK;
      b[4][4] = WHITE;
      return b;
    };

    const Othello = () => {
      const [board, setBoard] = useState(getInitialBoard);
      const [current, setCurrent] = useState(BLACK);
      const [difficulty, setDifficulty] = useState("normal");
      const [gameOver, setGameOver] = useState(false);

      const opponent = p => (p === BLACK ? WHITE : BLACK);

      const isValidMove = (b, r, c, p) => {
        if (b[r][c] !== EMPTY) return false;
        return directions.some(([dx, dy]) => {
          let x = r + dx, y = c + dy, found = false;
          while (x >= 0 && x < 8 && y >= 0 && y < 8) {
            if (b[x][y] === opponent(p)) found = true;
            else if (b[x][y] === p && found) return true;
            else break;
            x += dx; y += dy;
          }
          return false;
        });
      };

      const getMoves = (b, p) =>
        b.flatMap((row, r) =>
          row.map((_, c) => ({ r, c }))
             .filter(m => isValidMove(b, m.r, m.c, p))
        );

      const applyMove = (r, c, p) => {
        if (!isValidMove(board, r, c, p)) return;
        const next = board.map(row => [...row]);
        next[r][c] = p;

        directions.forEach(([dx, dy]) => {
          const flips = [];
          let x = r + dx, y = c + dy;
          while (x >= 0 && x < 8 && y >= 0 && y < 8) {
            if (next[x][y] === opponent(p)) flips.push([x, y]);
            else if (next[x][y] === p) {
              flips.forEach(([fx, fy]) => next[fx][fy] = p);
              break;
            } else break;
            x += dx; y += dy;
          }
        });

        setBoard(next);
        setCurrent(opponent(p));
      };

      const aiMove = () => {
        const moves = getMoves(board, WHITE);
        if (!moves.length) return;

        if (difficulty === "easy" || (difficulty === "normal" && Math.random() < 0.5)) {
          const m = moves[Math.floor(Math.random() * moves.length)];
          applyMove(m.r, m.c, WHITE);
          return;
        }

        // hard: 最大反転数
        let best = moves[0], bestScore = -1;
        for (const m of moves) {
          let score = 0;
          directions.forEach(([dx, dy]) => {
            let x = m.r + dx, y = m.c + dy;
            while (x >= 0 && x < 8 && y >= 0 && y < 8) {
              if (board[x][y] === BLACK) score++;
              else break;
              x += dx; y += dy;
            }
          });
          if (score > bestScore) {
            bestScore = score;
            best = m;
          }
        }
        applyMove(best.r, best.c, WHITE);
      };

      useEffect(() => {
        if (gameOver) return;

        const myMoves = getMoves(board, current);
        const oppMoves = getMoves(board, opponent(current));

        if (!myMoves.length && !oppMoves.length) {
          setGameOver(true);
          return;
        }

        if (current === WHITE && myMoves.length) {
          setTimeout(aiMove, 500);
        }
        if (current === WHITE && !myMoves.length) {
          setCurrent(BLACK);
        }
      }, [board, current]);

      return (
        <div className="p-6">
          <h1 className="text-3xl font-bold text-center mb-4">パステルオセロ</h1>

          <div className="flex justify-center gap-2 mb-4">
            {DIFFICULTY.map(d => (
              <button
                key={d}
                onClick={() => {
                  setDifficulty(d);
                  setBoard(getInitialBoard());
                  setCurrent(BLACK);
                  setGameOver(false);
                }}
                className={`px-3 py-1 rounded-full ${
                  difficulty === d ? "bg-blue-500 text-white" : "bg-blue-100"
                }`}
              >
                {d}
              </button>
            ))}
          </div>

          <div className="grid grid-cols-8 gap-1 max-w-xs mx-auto bg-green-300 p-2 rounded">
            {board.map((row, r) =>
              row.map((cell, c) => (
                <div
                  key={r + "-" + c}
                  onClick={() => current === BLACK && applyMove(r, c, BLACK)}
                  className="aspect-square bg-green-400 rounded flex items-center justify-center"
                >
                  {cell === BLACK && <div className="w-4/5 h-4/5 bg-black rounded-full" />}
                  {cell === WHITE && <div className="w-4/5 h-4/5 bg-white rounded-full" />}
                </div>
              ))
            )}
          </div>

          {gameOver && (
            <p className="text-center mt-4 font-bold">ゲーム終了</p>
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById("root")).render(<Othello />);
  </script>

  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./service-worker.js");
    }
  </script>
</body>
</html>
