<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ã®ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ  - AIã¨å¯¾æˆ¦ã—ã‚ˆã†!">
  <meta name="theme-color" content="#B8D4E8">
  <title>ãƒ‘ã‚¹ãƒ†ãƒ«ã‚ªã‚»ãƒ­</title>
  
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="./icon-512.png">
  <link rel="apple-touch-icon" href="./icon-192.png">
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    body { margin: 0; padding: 0; overflow-x: hidden; }
    .icon-btn svg { display: inline-block; vertical-align: middle; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // ã‚¢ã‚¤ã‚³ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ(Lucideä¾å­˜ã—ãªã„)
    const MenuIcon = () => (
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/>
      </svg>
    );
    const XIcon = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    );
    const UndoIcon = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 102.13-9.36L1 10"/>
      </svg>
    );
    const RotateCcwIcon = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 102.13-9.36L1 10"/>
      </svg>
    );

    const OthelloGame = () => {
      const BOARD_SIZE = 8;
      const EMPTY = 0;
      const BLACK = 1;
      const WHITE = 2;
      
      const DIFFICULTY = { EASY: 'easy', NORMAL: 'normal', HARD: 'hard', DEMON: 'demon' };

      const getInitialBoard = () => {
        const b = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
        b[3][3] = WHITE; b[3][4] = BLACK; b[4][3] = BLACK; b[4][4] = WHITE;
        return b;
      };

      const [board, setBoard] = useState(getInitialBoard);
      const [currentPlayer, setCurrentPlayer] = useState(BLACK);
      const [validMoves, setValidMoves] = useState([]);
      const [gameOver, setGameOver] = useState(false);
      const [history, setHistory] = useState([]);
      const [aiThinking, setAiThinking] = useState(false);
      const [difficulty, setDifficulty] = useState(DIFFICULTY.NORMAL);
      const [coinTossing, setCoinTossing] = useState(false);
      const [coinResult, setCoinResult] = useState(null);
      const [playerColor, setPlayerColor] = useState(BLACK);
      const [aiColor, setAiColor] = useState(WHITE);
      const [coinTossCount, setCoinTossCount] = useState(0);
      const [showDeathWarning, setShowDeathWarning] = useState(false);
      const [menuOpen, setMenuOpen] = useState(false);
      const [stats, setStats] = useState(() => {
        try {
          const saved = localStorage.getItem('othelloStats');
          if (saved) {
            const parsed = JSON.parse(saved);
            if (!parsed.difficultyStats.demon) parsed.difficultyStats.demon = { wins: 0, losses: 0 };
            return parsed;
          }
        } catch(e) {}
        return {
          recentGames: [],
          difficultyStats: {
            easy: { wins: 0, losses: 0 },
            normal: { wins: 0, losses: 0 },
            hard: { wins: 0, losses: 0 },
            demon: { wins: 0, losses: 0 }
          }
        };
      });

      useEffect(() => { setValidMoves(getValidMoves(board, BLACK)); }, []);
      useEffect(() => { try { localStorage.setItem('othelloStats', JSON.stringify(stats)); } catch(e) {} }, [stats]);

      useEffect(() => {
        if (board.length === 0) return;
        const moves = getValidMoves(board, currentPlayer);
        setValidMoves(moves);
        if (moves.length === 0 && !gameOver) {
          const opMoves = getValidMoves(board, currentPlayer === BLACK ? WHITE : BLACK);
          if (opMoves.length === 0) { endGame(); }
          else { setTimeout(() => { setCurrentPlayer(currentPlayer === BLACK ? WHITE : BLACK); }, 1000); }
        } else if (currentPlayer === aiColor && !gameOver && !aiThinking && !coinTossing) {
          setAiThinking(true);
          setTimeout(() => { makeAIMove(); setAiThinking(false); }, 800);
        }
      }, [currentPlayer, board, gameOver]);

      const initBoard = () => {
        const b = getInitialBoard();
        setBoard(b); setCurrentPlayer(BLACK); setGameOver(false);
        setHistory([]); setValidMoves(getValidMoves(b, BLACK));
      };

      const startNewGame = () => {
        setCoinTossing(true); setCoinResult(null);
        setCoinTossCount(prev => prev + 1);
        setTimeout(() => {
          const isFirst = Math.random() < 0.5;
          setCoinResult(isFirst ? 'heads' : 'tails');
          if (isFirst) { setPlayerColor(BLACK); setAiColor(WHITE); }
          else { setPlayerColor(WHITE); setAiColor(BLACK); }
          setTimeout(() => { setCoinTossing(false); initBoard(); }, 2000);
        }, 2000);
      };

      const redoCoinToss = () => {
        if (coinTossCount >= 2) {
          setShowDeathWarning(true);
          setTimeout(() => setShowDeathWarning(false), 3000);
          return;
        }
        if (!coinTossing) startNewGame();
      };

      const getValidMoves = (board, player) => {
        const moves = [];
        for (let r = 0; r < BOARD_SIZE; r++)
          for (let c = 0; c < BOARD_SIZE; c++)
            if (isValidMove(board, r, c, player)) moves.push({ row: r, col: c });
        return moves;
      };

      const isValidMove = (board, row, col, player) => {
        if (board[row][col] !== EMPTY) return false;
        const opp = player === BLACK ? WHITE : BLACK;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (const [dx, dy] of dirs) {
          let x = row+dx, y = col+dy, hasOpp = false;
          while (x>=0 && x<BOARD_SIZE && y>=0 && y<BOARD_SIZE) {
            if (board[x][y] === EMPTY) break;
            if (board[x][y] === opp) hasOpp = true;
            else if (board[x][y] === player && hasOpp) return true;
            else break;
            x+=dx; y+=dy;
          }
        }
        return false;
      };

      const makeMove = (row, col, player) => {
        if (!isValidMove(board, row, col, player)) return false;
        const nb = board.map(r => [...r]);
        nb[row][col] = player;
        const opp = player === BLACK ? WHITE : BLACK;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (const [dx, dy] of dirs) {
          const toFlip = [];
          let x = row+dx, y = col+dy;
          while (x>=0 && x<BOARD_SIZE && y>=0 && y<BOARD_SIZE) {
            if (nb[x][y] === EMPTY) break;
            if (nb[x][y] === opp) toFlip.push([x,y]);
            else if (nb[x][y] === player) { toFlip.forEach(([fx,fy]) => { nb[fx][fy] = player; }); break; }
            else break;
            x+=dx; y+=dy;
          }
        }
        setHistory([...history, { board: board.map(r => [...r]), player }]);
        setBoard(nb);
        setCurrentPlayer(player === BLACK ? WHITE : BLACK);
        return true;
      };
      
      const makeAIMove = () => {
        const moves = getValidMoves(board, aiColor);
        if (moves.length === 0) return;
        let selectedMove;
        if (difficulty === DIFFICULTY.EASY) {
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
        } else if (difficulty === DIFFICULTY.NORMAL) {
          const corners = moves.filter(m => (m.row===0||m.row===7)&&(m.col===0||m.col===7));
          if (corners.length > 0) { selectedMove = corners[Math.floor(Math.random()*corners.length)]; }
          else {
            const scored = moves.map(m => ({ move:m, score:evaluateMove(board,m.row,m.col,aiColor) }));
            scored.sort((a,b) => b.score-a.score);
            const top = scored.filter(s => s.score===scored[0].score);
            selectedMove = top[Math.floor(Math.random()*top.length)].move;
          }
        } else if (difficulty === DIFFICULTY.HARD) {
          selectedMove = minimaxMedium(board, aiColor, 3).move;
        } else if (difficulty === DIFFICULTY.DEMON) {
          selectedMove = minimaxAdvanced(board, aiColor, 5).move;
        }
        if (selectedMove) makeMove(selectedMove.row, selectedMove.col, aiColor);
      };

      const evaluateMove = (board, row, col, player) => {
        const opp = player === BLACK ? WHITE : BLACK;
        let score = 0;
        const corners = [[0,0],[0,7],[7,0],[7,7]];
        if (corners.some(([r,c]) => r===row&&c===col)) score += 100;
        if (row===0||row===7||col===0||col===7) score += 10;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (const [dx,dy] of dirs) {
          let x=row+dx, y=col+dy, flips=0;
          while (x>=0&&x<BOARD_SIZE&&y>=0&&y<BOARD_SIZE) {
            if (board[x][y]===EMPTY) break;
            if (board[x][y]===opp) flips++;
            else if (board[x][y]===player&&flips>0) { score+=flips; break; }
            else break;
            x+=dx; y+=dy;
          }
        }
        return score;
      };

      const simulateMove = (board, row, col, player) => {
        board[row][col] = player;
        const opp = player === BLACK ? WHITE : BLACK;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (const [dx,dy] of dirs) {
          const toFlip = [];
          let x=row+dx, y=col+dy;
          while (x>=0&&x<BOARD_SIZE&&y>=0&&y<BOARD_SIZE) {
            if (board[x][y]===EMPTY) break;
            if (board[x][y]===opp) toFlip.push([x,y]);
            else if (board[x][y]===player) { toFlip.forEach(([fx,fy]) => board[fx][fy]=player); break; }
            else break;
            x+=dx; y+=dy;
          }
        }
      };

      const positionWeights = [
        [100,-20,10,5,5,10,-20,100],
        [-20,-50,-2,-2,-2,-2,-50,-20],
        [10,-2,-1,-1,-1,-1,-2,10],
        [5,-2,-1,-1,-1,-1,-2,5],
        [5,-2,-1,-1,-1,-1,-2,5],
        [10,-2,-1,-1,-1,-1,-2,10],
        [-20,-50,-2,-2,-2,-2,-50,-20],
        [100,-20,10,5,5,10,-20,100]
      ];

      const evaluateBoardMedium = (board, player) => {
        const opp = player === BLACK ? WHITE : BLACK;
        let score = 0;
        for (let i=0;i<BOARD_SIZE;i++)
          for (let j=0;j<BOARD_SIZE;j++) {
            if (board[i][j]===player) score += positionWeights[i][j];
            else if (board[i][j]===opp) score -= positionWeights[i][j];
          }
        return score;
      };

      const minimaxMedium = (board, player, depth, alpha=-Infinity, beta=Infinity) => {
        if (depth===0) return { score: evaluateBoardMedium(board, aiColor), move: null };
        const moves = getValidMoves(board, player);
        if (moves.length===0) {
          const opMoves = getValidMoves(board, player===aiColor?playerColor:aiColor);
          if (opMoves.length===0) return { score: evaluateBoardMedium(board, aiColor), move: null };
          return minimaxMedium(board, player===aiColor?playerColor:aiColor, depth-1, alpha, beta);
        }
        let bestMove=moves[0], bestScore = player===aiColor ? -Infinity : Infinity;
        for (const move of moves) {
          const tmp = board.map(r=>[...r]);
          simulateMove(tmp, move.row, move.col, player);
          const res = minimaxMedium(tmp, player===aiColor?playerColor:aiColor, depth-1, alpha, beta);
          if (player===aiColor) { if(res.score>bestScore){bestScore=res.score;bestMove=move;} alpha=Math.max(alpha,res.score); }
          else { if(res.score<bestScore){bestScore=res.score;bestMove=move;} beta=Math.min(beta,res.score); }
          if (beta<=alpha) break;
        }
        return { score: bestScore, move: bestMove };
      };

      const countStableDiscs = (board, player) => {
        let count = 0;
        const corners = [[0,0],[0,7],[7,0],[7,7]];
        for (const [cr,cc] of corners) {
          if (board[cr][cc]===player) {
            count++;
            const rowDir = cr===0?1:-1;
            for (let i=cr+rowDir;i>=0&&i<BOARD_SIZE;i+=rowDir) { if(board[i][cc]===player)count++; else break; }
            const colDir = cc===0?1:-1;
            for (let j=cc+colDir;j>=0&&j<BOARD_SIZE;j+=colDir) { if(board[cr][j]===player)count++; else break; }
          }
        }
        return count;
      };

      const evaluateBoardAdvanced = (board, player) => {
        const opp = player === BLACK ? WHITE : BLACK;
        let score = 0;
        for (let i=0;i<BOARD_SIZE;i++)
          for (let j=0;j<BOARD_SIZE;j++) {
            if (board[i][j]===player) score += positionWeights[i][j];
            else if (board[i][j]===opp) score -= positionWeights[i][j];
          }
        score += (countStableDiscs(board,player)-countStableDiscs(board,opp))*25;
        score += (getValidMoves(board,player).length-getValidMoves(board,opp).length)*5;
        const corners=[[0,0],[0,7],[7,0],[7,7]];
        for (const [r,c] of corners) { if(board[r][c]===player)score+=100; if(board[r][c]===opp)score-=100; }
        return score;
      };

      const evaluateMoveQuick = (board, row, col) => {
        const corners=[[0,0],[0,7],[7,0],[7,7]];
        if (corners.some(([r,c])=>r===row&&c===col)) return 1000;
        const danger=[[0,1],[1,0],[1,1],[0,6],[1,6],[1,7],[6,0],[6,1],[7,1],[6,6],[6,7],[7,6]];
        if (danger.some(([r,c])=>r===row&&c===col)) return -500;
        return (row===0||row===7||col===0||col===7) ? 100 : 0;
      };

      const minimaxAdvanced = (board, player, depth, alpha=-Infinity, beta=Infinity) => {
        if (depth===0) return { score: evaluateBoardAdvanced(board, aiColor), move: null };
        const moves = getValidMoves(board, player);
        if (moves.length===0) {
          const opp = player===aiColor?playerColor:aiColor;
          const opMoves = getValidMoves(board, opp);
          if (opMoves.length===0) return { score: evaluateBoardAdvanced(board, aiColor), move: null };
          return minimaxAdvanced(board, opp, depth-1, alpha, beta);
        }
        let bestMove=moves[0], bestScore = player===aiColor ? -Infinity : Infinity;
        const sorted = [...moves].sort((a,b) => evaluateMoveQuick(board,b.row,b.col)-evaluateMoveQuick(board,a.row,a.col));
        for (const move of sorted) {
          const tmp = board.map(r=>[...r]);
          simulateMove(tmp, move.row, move.col, player);
          const opp = player===aiColor?playerColor:aiColor;
          const res = minimaxAdvanced(tmp, opp, depth-1, alpha, beta);
          if (player===aiColor) { if(res.score>bestScore){bestScore=res.score;bestMove=move;} alpha=Math.max(alpha,res.score); }
          else { if(res.score<bestScore){bestScore=res.score;bestMove=move;} beta=Math.min(beta,res.score); }
          if (beta<=alpha) break;
        }
        return { score: bestScore, move: bestMove };
      };

      const handleCellClick = (row, col) => {
        if (currentPlayer===playerColor && !gameOver && !aiThinking && !coinTossing) makeMove(row,col,playerColor);
      };

      const undo = () => {
        if (history.length>=2) {
          const nh = [...history]; nh.pop(); nh.pop();
          const last = nh[nh.length-1];
          if (last) { setBoard(last.board); setCurrentPlayer(playerColor); }
          else initBoard();
          setHistory(nh); setGameOver(false);
        }
      };

      const endGame = () => {
        setGameOver(true); setCoinTossCount(0);
        const { black, white } = countPieces();
        const ps = playerColor===BLACK?black:white;
        const as = aiColor===BLACK?black:white;
        const result = ps>as?'win':ps<as?'loss':'draw';
        const newGame = { date:new Date().toISOString(), difficulty, playerScore:ps, aiScore:as, result, playerColor:playerColor===BLACK?'black':'white' };
        const ns = { ...stats };
        ns.recentGames = [newGame,...stats.recentGames].slice(0,5);
        if (result==='win') ns.difficultyStats[difficulty].wins++;
        else if (result==='loss') ns.difficultyStats[difficulty].losses++;
        setStats(ns);
      };

      const countPieces = () => {
        let black=0, white=0;
        board.forEach(row => row.forEach(cell => { if(cell===BLACK)black++; if(cell===WHITE)white++; }));
        return { black, white };
      };

      const getAIEmotion = () => {
        const { black, white } = countPieces();
        const diff = (aiColor===BLACK?black:white)-(playerColor===BLACK?black:white);
        if (diff>15) return 'ğŸ˜';
        if (diff>8) return 'ğŸ˜';
        if (diff>3) return 'ğŸ™‚';
        if (diff>-3) return 'ğŸ¤”';
        if (diff>-8) return 'ğŸ˜°';
        return 'ğŸ˜“';
      };

      const { black, white } = countPieces();
      const playerScore = playerColor===BLACK?black:white;
      const aiScore = aiColor===BLACK?black:white;
      
      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-green-50 p-4">
          {coinTossing && (
            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center">
              <div className="bg-white rounded-3xl p-12 text-center shadow-2xl">
                <h2 className="text-3xl font-bold text-gray-800 mb-8">ã‚³ã‚¤ãƒ³ãƒˆã‚¹!</h2>
                <div className="mb-8 flex justify-center">
                  <div className={`w-32 h-32 rounded-full flex items-center justify-center text-6xl shadow-lg ${coinResult===null?'animate-coin-flip':''}`}
                    style={{ background:coinResult===null?'linear-gradient(135deg,#FFD700,#FFA500)':coinResult==='heads'?'#2c2c2c':'#f5f5f5', border:'4px solid #FFD700' }}>
                    {coinResult===null?'ğŸª™':coinResult==='heads'?'âš«':'âšª'}
                  </div>
                </div>
                {coinResult && (
                  <div>
                    <p className="text-2xl font-bold mb-2" style={{color:coinResult==='heads'?'#2c2c2c':'#666'}}>
                      {coinResult==='heads'?'ã‚ãªãŸã¯å…ˆæ”»(é»’)ã§ã™!':'ã‚ãªãŸã¯å¾Œæ”»(ç™½)ã§ã™!'}
                    </p>
                    <p className="text-gray-600">
                      {coinResult==='heads'?'æœ€åˆã®ä¸€æ‰‹ã‚’æ‰“ã£ã¦ãã ã•ã„':'AIãŒå…ˆæ‰‹ã‚’æ‰“ã¡ã¾ã™'}
                    </p>
                  </div>
                )}
              </div>
            </div>
          )}

          {showDeathWarning && (
            <div className="fixed inset-0 bg-black/70 z-50 flex items-center justify-center">
              <div className="bg-gray-900 rounded-3xl p-12 text-center shadow-2xl border-4 border-red-600">
                <div className="text-8xl mb-6 animate-skull-shake">ğŸ’€</div>
                <h2 className="text-4xl font-bold text-red-500 mb-4">ã“ã‚Œä»¥ä¸Šã¯ãƒ€ãƒ¡ã§ã™</h2>
                <p className="text-gray-300 text-lg">é‹å‘½ã‚’å—ã‘å…¥ã‚Œãªã•ã„...</p>
              </div>
            </div>
          )}

          <style>{`
            @keyframes coin-flip {
              0%{transform:rotateY(0deg) translateY(0px);}
              25%{transform:rotateY(180deg) translateY(-20px);}
              50%{transform:rotateY(360deg) translateY(0px);}
              75%{transform:rotateY(540deg) translateY(-20px);}
              100%{transform:rotateY(720deg) translateY(0px);}
            }
            .animate-coin-flip { animation: coin-flip 2s ease-in-out infinite; }
            @keyframes skull-shake {
              0%,100%{transform:rotate(0deg);}
              25%{transform:rotate(-15deg);}
              75%{transform:rotate(15deg);}
            }
            .animate-skull-shake { animation: skull-shake 0.5s ease-in-out infinite; }
          `}</style>

          <div className="max-w-6xl mx-auto">
            <div className="flex justify-between items-center mb-4">
              <h1 className="text-3xl font-bold text-gray-700">ãƒ‘ã‚¹ãƒ†ãƒ«ã‚ªã‚»ãƒ­</h1>
              <button onClick={()=>setMenuOpen(!menuOpen)} className="lg:hidden p-3 bg-white/80 rounded-xl shadow-lg">
                {menuOpen ? <XIcon size={28}/> : <MenuIcon />}
              </button>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
              <div className="lg:col-span-2">
                <div className="bg-white/80 rounded-3xl shadow-lg p-4">
                  <div className="flex justify-around mb-4">
                    <div className={`text-center p-3 rounded-2xl ${currentPlayer===playerColor?'bg-gray-200':'bg-gray-50'}`}>
                      <div className="text-2xl mb-1">{playerColor===BLACK?'âš«':'âšª'}</div>
                      <div className="text-xs text-gray-600">ã‚ãªãŸ</div>
                      <div className="text-2xl font-bold text-gray-800">{playerScore}</div>
                    </div>
                    <div className={`text-center p-3 rounded-2xl ${currentPlayer===aiColor?'bg-blue-100':'bg-gray-50'}`}>
                      <div className="text-2xl mb-1">{aiThinking?'ğŸ’­':getAIEmotion()}</div>
                      <div className="text-xs text-gray-600">AI</div>
                      <div className="text-2xl font-bold text-gray-800">{aiScore}</div>
                    </div>
                  </div>

                  <div className="bg-green-100 p-2 rounded-2xl shadow-inner max-w-md mx-auto">
                    <div className="grid grid-cols-8 gap-0.5">
                      {board.map((row,i) => row.map((cell,j) => {
                        const isValid = validMoves.some(m=>m.row===i&&m.col===j);
                        return (
                          <div key={`${i}-${j}`} onClick={()=>handleCellClick(i,j)}
                            className={`aspect-square bg-green-200 rounded flex items-center justify-center cursor-pointer
                              ${isValid&&currentPlayer===playerColor&&!gameOver?'hover:bg-green-300 ring-2 ring-green-400':''}`}>
                            {cell===BLACK && <div className="w-4/5 h-4/5 bg-gray-800 rounded-full shadow-md"></div>}
                            {cell===WHITE && <div className="w-4/5 h-4/5 bg-white border border-gray-300 rounded-full shadow-md"></div>}
                            {cell===EMPTY && isValid && currentPlayer===playerColor && !gameOver && <div className="w-2 h-2 bg-gray-400/50 rounded-full"></div>}
                          </div>
                        );
                      }))}
                    </div>
                  </div>

                  <div className="flex gap-3 mt-4">
                    <button onClick={undo} disabled={history.length<2||gameOver}
                      className="flex-1 flex items-center justify-center gap-2 px-4 py-3 bg-blue-200 text-gray-700 rounded-xl hover:bg-blue-300 disabled:bg-gray-200 disabled:text-gray-400">
                      <UndoIcon /> å¾…ã£ãŸ
                    </button>
                    <button onClick={startNewGame}
                      className="flex-1 flex items-center justify-center gap-2 px-4 py-3 text-gray-700 rounded-xl"
                      style={{backgroundColor:'#FFCCBC'}}>
                      <RotateCcwIcon /> æ–°è¦ã‚²ãƒ¼ãƒ 
                    </button>
                  </div>

                  {coinResult && !gameOver && coinTossCount<2 && (
                    <button onClick={redoCoinToss} disabled={coinTossing}
                      className={`w-full mt-3 px-4 py-3 rounded-xl text-sm font-bold ${coinTossCount===1?'bg-red-100 text-red-700 border-2 border-red-300':'bg-yellow-100 text-gray-700'}`}>
                      {coinTossCount===1?'ğŸ’€ æ³£ãã®ä¸€å›!ã“ã‚ŒãŒæœ€å¾Œã§ã™...':'ğŸª™ ã‚³ã‚¤ãƒ³ãƒˆã‚¹ã‚„ã‚Šç›´ã— (æ®‹ã‚Š2å›)'}
                    </button>
                  )}

                  {gameOver && (
                    <div className="mt-4 p-4 bg-blue-100 rounded-2xl text-center">
                      <div className="text-2xl font-bold text-gray-800 mb-1">
                        {playerScore>aiScore?'ğŸ‰ ã‚ãªãŸã®å‹ã¡!':playerScore<aiScore?'ğŸ˜¢ AIã®å‹ã¡':'ğŸ¤ å¼•ãåˆ†ã‘'}
                      </div>
                      <div className="text-gray-600">æœ€çµ‚ã‚¹ã‚³ã‚¢ - ã‚ãªãŸ: {playerScore} | AI: {aiScore}</div>
                      <div className="text-sm text-gray-500 mt-1">ã‚ãªãŸã¯{playerColor===BLACK?'å…ˆæ”»(é»’)':'å¾Œæ”»(ç™½)'}ã§ã—ãŸ</div>
                    </div>
                  )}
                </div>
              </div>

              <div className={`${menuOpen?'block':'hidden'} lg:block fixed lg:relative inset-0 lg:inset-auto z-40 lg:z-auto bg-black/50 lg:bg-transparent p-4 lg:p-0`}
                onClick={(e)=>e.target===e.currentTarget&&setMenuOpen(false)}>
                <div className="bg-white/95 lg:bg-transparent rounded-3xl lg:rounded-none p-4 lg:p-0 max-h-screen overflow-y-auto space-y-4">
                  <button onClick={()=>setMenuOpen(false)} className="lg:hidden ml-auto block p-2 bg-gray-100 rounded-xl">
                    <XIcon size={24}/>
                  </button>

                  <div className="bg-white/80 rounded-3xl shadow-lg p-4">
                    <h3 className="text-lg font-bold text-gray-700 mb-3">é›£æ˜“åº¦</h3>
                    <div className="space-y-2">
                      {[
                        {value:DIFFICULTY.EASY,label:'ç°¡å˜',emoji:'ğŸ˜Š'},
                        {value:DIFFICULTY.NORMAL,label:'æ™®é€š',emoji:'ğŸ¤”'},
                        {value:DIFFICULTY.HARD,label:'é›£ã—ã„',emoji:'ğŸ˜¤'},
                        {value:DIFFICULTY.DEMON,label:'é¬¼ğŸ‘¹',emoji:'ğŸ‘¹'}
                      ].map(({value,label,emoji})=>(
                        <button key={value} onClick={()=>{setDifficulty(value);startNewGame();setMenuOpen(false);}}
                          className={`w-full px-4 py-3 rounded-xl ${difficulty===value?'bg-blue-200 text-gray-800 font-bold':'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}>
                          {emoji} {label}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="bg-white/80 rounded-3xl shadow-lg p-4">
                    <h3 className="text-lg font-bold text-gray-700 mb-3">é€šç®—æˆç¸¾</h3>
                    <div className="space-y-2">
                      {Object.entries(stats.difficultyStats).map(([diff,{wins,losses}])=>(
                        <div key={diff} className="bg-gray-50 rounded-xl p-3">
                          <div className="text-sm text-gray-600 mb-1 capitalize">{diff}</div>
                          <div className="flex justify-between text-sm">
                            <span className="text-green-600">å‹åˆ©: {wins}</span>
                            <span className="text-red-600">æ•—åŒ—: {losses}</span>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  <div className="bg-white/80 rounded-3xl shadow-lg p-4">
                    <h3 className="text-lg font-bold text-gray-700 mb-3">ç›´è¿‘5æˆ¦</h3>
                    <div className="space-y-2">
                      {stats.recentGames.length===0?(
                        <div className="text-center text-gray-400 py-4">ã¾ã å¯¾æˆ¦å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>
                      ):(
                        stats.recentGames.map((game,idx)=>(
                          <div key={idx} className="bg-gray-50 rounded-xl p-3 text-sm">
                            <div className="flex justify-between items-center mb-1">
                              <span className="capitalize text-gray-600">{game.difficulty}</span>
                              <span className={`font-bold ${game.result==='win'?'text-green-600':game.result==='loss'?'text-red-600':'text-gray-600'}`}>
                                {game.result==='win'?'å‹åˆ©':game.result==='loss'?'æ•—åŒ—':'å¼•åˆ†'}
                              </span>
                            </div>
                            <div className="text-gray-500 text-xs flex justify-between">
                              <span>{game.playerScore} - {game.aiScore}</span>
                              <span>{game.playerColor==='black'?'å…ˆæ”»âš«':'å¾Œæ”»âšª'}</span>
                            </div>
                          </div>
                        ))
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<OthelloGame />);
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('SW registered:', reg))
          .catch(err => console.log('SW failed:', err));
      });
    }
  </script>
</body>
</html>
      
